ITER_TYPES = {'int', 'prod', 'sum'}
SPLIT_OPERATORS = ONE_CHAR_OPERATOR

TAKE_ENSURE(content, name):
    assert content && content.peek().name == name
    return content.next()

PARSE_INNER(cell, func=TOP):
    ðŸ ’ Holder(cell.name, func(cell.data).data)

ITERABLE_SCANNER(content):
    first = name, args = content.next()
    lower = TAKE_ENSURE(content, "subscript")
    upper = TAKE_ENSURE(content, "superscript")
    body = Holder("ITER_BODY")
    while p := content.peek():
        p.name == "OPERATOR" && p.args[0] âˆˆ SPLIT_OPERATORS:
            break
        body += content.next()
    ðŸ ’ Holder("ITERABLE", [PARSE_INNER(lower), PARSE_INNER(upper), PARSE_INNER(body)])

VAR_SCANNER(content):
    first = name, args = content.next()
    VAR = Holder("VAR", [content.next()])
    
    not (r := content.peek()): ðŸ ’ VAR
    r.name == "subscript":
        VAR += content.next()
        not (r := content.peek()): ðŸ ’ VAR
    # maybe implement array variable type stuff here?
    r.name == "SYMBOL" && r.args[0] == '.':
        not (t := r.peek()): ðŸ ’ VAR
        t.name âˆˆ {"VARIABLE", "SYMBOL"}:
            VAR += content.next() # add dot
            VAR += VAR_SCANNER(content).data # add the rest
    ðŸ ’ VAR
    
TOP(content, contain_scope=None):
    isinstance(content, list):
        content = Holder(data=content)
    contain_scope is None:
        contain_scope = Holder()
    
    whilematch c := content.peek():s
        name, args = c
        
        name âˆˆ {"VARIABLE", "SYMBOL"}:
            name == "SYMBOL" && c.args[0] âˆˆ ITER_TYPES:
                contain_scope += ITERABLE_SCANNER(content)
            else:
                contain_scope += VAR_SCANNER(content)
            continue
        
        contain_scope += c.next()
        
    ðŸ ’ contain_scope
    